/**
  * Copyright (c) 2013-2015  Patrick Nicolas - Scala for Machine Learning - All rights reserved
  *
  * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file
  * except in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *
  * The source code in this file is provided by the author for the sole purpose of illustrating the
  * concepts and algorithms presented in "Scala for Machine Learning".
  * ISBN: 978-1-783355-874-2 Packt Publishing.
  *
  * Version 0.99
  */
package org.scalaml.validation

import scala.util.Try

import org.scalaml.util.MapUtils.Counter
import org.scalaml.supervised.Supervised
import org.scalaml.core.Types.ScalaMl._

/**
  * Enumeration for validation labels such as TP (true positive), TN (true negative)
  * FP (false positive) and FN (false negative)
  * @author Patrick Nicolas
  */
object Label extends Enumeration(0) {
  type Label = Value
  val TP, TN, FP, FN = Value
}


import Label._, BinFValidation._


/**
  * Immutable class that implements the metrics to validate a model with two classes
  * (or binomial F validation). The validation is applied to a test or validation run
  * The counters for TP, TN, FP and FN are computed during instantiation
  * to the class, Accuracy, precision and recall are computed at run-time (lazy values).
  * {{{
  *    precision = TP/(TP + FP)
  *    recall  TP/(TP + FN)
  *    F1 = 2.precision.recall/(precision + recall)
  *    F2 = 5.precision.recall/(4.precision + recall)
  *    Fn = (1+n.n).precision.recall/(n.n.precision + recall)
  *    G = Sqrt(precision.recall)
  * }}}
  * @constructor Create a class validation instance that compute precision, recall and F1 measure
  * @throws IllegalArgumentException if actualExpected is undefined or has no elements or
  *                                  tpClass is out of range
  * @param actual Array of label or actual values
  * @param xt time series or set of observations used for validating the model
  * @param predict function that predict the class of a new observation. The function is
  *                generated by the classifier.

  * @author Patrick Nicolas
  * @since 0.98.2 February 1, 2014
  * @see Scala for Machine Learning Chapter 2 "Hello World!" / Assessing a model / Validation
  * @see org.scalaml.validation.MultiFValidation
  * @note The quality metrics are computed for the class of index 1 which is contained
  *       arbitrary the positive outcome. Computation of precision and recall for an entire model is
  *       performed by the class '''MultiFValidation'''
  */
@throws(classOf[IllegalArgumentException])
final class BinFValidation[T <: AnyVal](
                                         expected: Vector[Int],
                                         xt: XVSeries[T])(predict: Array[T] => Int)(implicit f: T => Double)
  extends FValidation[T](expected, xt)(predict) {


  private[this] val counters: Counter[Label] = {
    val predicted = xt.map(predict(_))

    println(expected.mkString(","))
    println(predicted.mkString(","))
    expected.zip(predicted)./:(new Counter[Label]) {
      case (cnt, (y, x)) => cnt + classify(x, y)
    }
  }

  /**
    * Implements the computation of the score of the validation of a classifier for
    * the F-measure. By default the score use the F1-score.
    * @return F1 score of the classification
    */
  override def score: Double = f1

  /**
    * Compute the F1 measure for this classifier as (precision + recall)/(2.precision.recall)
    * @return F1 measure using precomputed precision and recall
    */
  lazy val f1: Double = 2.0 * precision * recall / (precision + recall)

  /**
    * Compute the Fn measure for this classifier as
    * (1+n*n).precision.recall/(n*n*precision + recall)
    * @param degree of the F measure
    * @return Fn measure
    * @throws IllegalArgumentException if the degree of the measure is null or negative
    * @throws IllegalStateException if some of counters are null
    */
  @throws(classOf[IllegalArgumentException])
  @throws(classOf[IllegalStateException])
  def fn(n: Int): Double = {
    require(n > 0, s"BinFValidation.fn degree of measure or score $n should be > 0")

    val n2 = n * n
    (1 + n2) * precision * recall / (n2 * precision + recall)
  }


  /**
    * Compute the geometric mean of precision and recall for this classifier as
    * Sqrt(precision.recall)
    * @return Geometric mean of precision and recall
    * @throws IllegalStateException if some of counters are null
    */
  @throws(classOf[IllegalStateException])
  def g: Double = Math.sqrt(precision * recall)


  /**
    * Accuracy of a classifier using TP and TN counters.
    * @return Accuracy for the model
    */
  lazy val accuracy: Double = {
    val num = (counters(TP) + counters(TN)).toDouble
    num / counters.aggregate(0)((s, kv) => s + kv._2, _ + _)
  }


  /**
    * Precision of a classifier using TP and FP counters.
    * @return Precision for the model if either TP or FP counters is not null
    * @throws IllegalStateException if some counters are null
    */
  @throws(classOf[IllegalStateException])
  lazy val precision = compute(FP)


  /**
    * Recall of a classifier using TP and FN counters.
    * @return recall value for the model or classifier
    * @throws IllegalStateException if some counters are null
    */
  @throws(classOf[IllegalStateException])
  lazy val recall = compute(FN)


  private def compute(n: Label): Double = {
    val denom = counters(TP) + counters(n)
    if (denom < 1)
      throw new IllegalStateException(s"BinFValidation.compute TP = $TP or n =$n should be > 0")
    counters(TP).toDouble / denom
  }


  private def classify(computed: Int, label: Int): Label =
    if (computed == label)
      if (label == POSITIVE) TP else TN
    else if (label == POSITIVE) FN else FP
}


/**
  * Companion object to the Class validation class that implement the constructors apply
  * @author Patrick Nicolas
  * @since February 1, 2014
  * @note Scala for Machine Learning Chapter 2 Hello World! / Assessing a model / Validation
  */
object BinFValidation {
  final val POSITIVE = 1

  /**
    * Default constructor for the ClassValidation
    * @param actualExpected Array of pair (actual value, labeled/expected value)
    * @param tpClass Identifier for the class that defined the true positive samples
    */
  def apply[T <: AnyVal](
                          expected: Vector[Int],
                          xt: XVSeries[T])(predict: Array[T] => Int)
                        (implicit f: T => Double): Try[BinFValidation[T]] = Try {
    new BinFValidation(expected, xt)(predict)
  }
}


// --------------------  EOF --------------------------------------------------------