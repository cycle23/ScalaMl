/**
  * Copyright (c) 2013-2015  Patrick Nicolas - Scala for Machine Learning - All rights reserved
  *
  * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file
  * except in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *
  * The source code in this file is provided by the author for the sole purpose of illustrating the
  * concepts and algorithms presented in "Scala for Machine Learning".
  * ISBN: 978-1-783355-874-2 Packt Publishing.
  *
  * Version 0.99
  */
package org.scalaml.app.chap5

// Scala standard library
import scala.util.{Try, Success, Failure, Random}
import scala.collection._
import org.apache.log4j.Logger

import org.scalaml.stats.XTSeries
import org.scalaml.core.Types.ScalaMl
import org.scalaml.workflow.data.{DataSource, DocumentsSource}
import org.scalaml.filtering.dft.DFT
import org.scalaml.filtering.movaverage.SimpleMovingAverage
import org.scalaml.supervised.bayes.NaiveBayes
import org.scalaml.util.{DisplayUtils, LoggingUtils}
import org.scalaml.app.Eval
import LoggingUtils._

/**
  * '''Purpose:''' Singleton to evaluate the Binomial Naive Bayes algorithm to classify
  * mathematical functions. The two categories of mathematical functions are sinusoidal and
  * the rectangular function. The mathematical functions are characterized by the frequency
  * spectrum of the time series generated by the functions. The indices of the ordered
  * frequencies are used to score the mathematical functions. The frequencies are computed
  * using the Discrete Fourier series.
  *
  * @author Patrick Nicolas
  * @since July 3, 2014
  * @note: Scala for Machine Learning Chapter 5: Naive Bayes Models
  */
object FunctionClassificationEval extends Eval {

  import ScalaMl._, SimpleMovingAverage._

  /**
    * Name of the evaluation
    */
  val name: String = "NaiveBayesEval"

  type Input = Vector[(DblArray, Int)]

  private val DATA_SIZE = 1025
  private val ALPHA = 1e-3
  private val BETA = 1e-2
  private val GAMMA = ALPHA * 0.1
  private val SPECTRUM = 24

  /**
    * Execution of the scalatest for '''NaiveBayes''' class
    * This method is invoked by the  actor-based test framework function, ScalaMlTest.evaluate
    *
    * Exceptions thrown during the execution of the tests are caught by the wrapper or handler
    * test method in Eval trait defined as follows:
    * {{{
    *    def test(args: Array[String]) =
    *      Try(run(args)) match {
    *        case Success(n) => ...
    *        case Failure(e) => ...
    * }}}
    * The tests can be executed through ''sbt run'' or individually by calling
    * ''TestName.test(args)'' (i.e. DKalmanEval.test(Array[String]("IBM") )
    * @param args array of arguments used in the test
    */
  override protected def run(args: Array[String]): Int = {
    import scala.language.postfixOps
    import XTSeries._

    show(s"$header Function classification using Naive Bayes")
    /**
      * Labeled mathematical functions.
      */
    val functionsGroup = Array[Double => Double](
      (x: Double) => {
        val a = ALPHA * (0.5 + GAMMA * Random.nextDouble)
        val b = BETA * (0.5 + GAMMA * Random.nextDouble)
        Math.sin(a * x) + Math.cos(b * x)
      },
      (x: Double) => if (x > 0.48 && x < 0.52) 1.0 else 0.0
    )

    /**
      * Training set using the labeled mathematical functions
      */
    def trainingDatasets(numSamples: Int): Input =
      Vector.tabulate(numSamples)(n => {
        val index = Random.nextInt(functionsGroup.size)
        val sets = createDatasets(functionsGroup(index), numSamples)
        (sets, index)
      })


    /**
      * Method to create datasets for training and testing. It normalizes the values, then computes
      * the frequencies related to the datasets, ranks the data points in decreasing order of their
      * frequency and return the SPECTUM indices of the data point with the highest frequency.
      * @param f Transformation of Double floating point values
      * @param dataRange Range of the data to be selected for the Discrete Fourier series
      * @return normalized vector of frequencies
      */
    def createDatasets(f: Double => Double, numSamples: Int): DblArray = {
      val values = Range(0, numSamples).map(_ / DATA_SIZE.toDouble).map(f(_)).toVector
      val min = values.min
      val delta = values.max - min


      val pfnDFT = DFT[Double] |>
      val input = values.map(x => (x - min) / delta)

      pfnDFT(input).map(freq => {
        val freQ = freq.zipWithIndex.sortWith(_._1 > _._1).toArray
        freQ.take(SPECTRUM).map(_._2.toDouble / DATA_SIZE)
      })
        .getOrElse(Array.empty[Double])
    }

    /**
      * Method to generate datasets for testing
      */
    def testDataset(f: Double => Double): Vector[DblArray] =
      createDatasets(f, DATA_SIZE).map(Array[Double](_)).toVector

    /**
      * Our test functions.
      */
    val g = (x: Double) => Math.cos(ALPHA * x)
    val h = (x: Double) => if (x >= 0.49 && x <= 0.51) 1.0 else 0.0

    /**
      * Scoring function. The linear comparison is used instead of the Gaussian
      * distribution because the standard deviation is very small and potentially
      * introduces significant rounding errors
      */
    def scoring(x: Double*): Double = Math.abs(x(2) - x(0))


    val nb = NaiveBayes(1.0, trainingDatasets(3), scoring, 2)

    show(s"$header Trained model for function classification ${nb.toString}")
    val result1 = testDataset(g).map(nb |> _).mkString(",")
    show(s"$name Naive Bayes classification for 'cos(ALPHA*x)' classes: ${result1}")

    val result2 = testDataset(h).map(nb |> _).mkString(",")
    show(s"$name Naive Bayes classify for 'if(x ~ 0.5) 1.0 else 0' class: ${result2}")

  }
}

// -----------------------------  EOF ------------------------------------