/**
  * Copyright (c) 2013-2015  Patrick Nicolas - Scala for Machine Learning - All rights reserved
  *
  * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file
  * except in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *
  * The source code in this file is provided by the author for the sole purpose of illustrating the
  * concepts and algorithms presented in "Scala for Machine Learning".
  * ISBN: 978-1-783355-874-2 Packt Publishing.
  *
  * Version 0.99
  */
package org.scalaml.app.chap9

import scala.annotation.switch
import scala.util.{Random, Try}

import org.apache.log4j.Logger

import org.scalaml.supervised.nnet.{MLPConfig, MLP}
import org.scalaml.stats.XTSeries
import org.scalaml.core.Types.ScalaMl._
import org.scalaml.util.{DisplayUtils, LoggingUtils}
import org.scalaml.app.Eval
import LoggingUtils._, XTSeries._

/**
  * '''Purpose:'''Singleton to evaluate the configuration parameters eta
  * and alpha of the multi-layer perceptron using synthetic data generated by random generators.
  *
  *
  * @author Patrick Nicolas
  * @note Scala for Machine Learning Chapter 9: Artificial Neural Network/Evaluation/Test case
  */
object MLPConfigEval extends Eval {


  /**
    * Name of the evaluation
    */
  val name: String = "MLPConfigEval"

  private val ALPHA = 0.9
  private val ETA = 0.001
  private val SIZE_HIDDEN_LAYER = 3
  private val TEST_SIZE = 30
  private val NUM_EPOCHS = 750
  private val NOISE_RATIO = 0.7
  private val EPS = 1e-8

  implicit val mlpObjective = new MLP.MLPBinClassifier

  /**
    * Execution of the scalatest for '''MLP''' class.
    * This method is invoked by the  actor-based test framework function, ScalaMlTest.evaluate
    *
    * Exceptions thrown during the execution of the tests are caught by the wrapper or handler
    * test method in Eval trait defined as follows:
    * {{{
    *    def test(args: Array[String]) =
    *      Try(run(args)) match {
    *        case Success(n) => ...
    *        case Failure(e) => ...
    * }}}
    * The tests can be executed through ''sbt run'' or individually by calling
    * ''TestName.test(args)'' (i.e. DKalmanEval.test(Array[String]("IBM") )
    *
    * @param args array of arguments used in the test
    */
  override protected def run(args: Array[String]): Int = {
    show(s"$header MLP configuration parameters for ${args(0)}")


    val noise = () => NOISE_RATIO * Random.nextDouble
    val f1 = (x: Double) => x * (1.0 + noise())
    val f2 = (x: Double) => x * x * (1.0 + noise())

    def vec1(x: Double): DblArray = Array[Double](f1(x), noise(), f2(x), noise())
    def vec2(x: Double): DblArray = Array[Double](noise(), noise())

    val x = Vector.tabulate(TEST_SIZE)(vec1(_))
    val y = Vector.tabulate(TEST_SIZE)(vec2(_))

    // Normalization._
    val xv = normalize(x).get
    val expected = normalize(y).get

    if (args.length > 0) {
      args(0) match {
        case "alpha" => eval(-1.0, ETA, xv, expected)
        case "eta" => eval(ALPHA, -1.0, xv, expected)
        case _ => eval(-1.0, -1.0, xv, expected)
      }
    }
    else
      eval(-1.0, -1.0, xv, expected)
  }

  private def eval(
                    alpha: Double,
                    eta: Double,
                    xv: XVSeries[Double],
                    expected: XVSeries[Double]): Int = {

    import org.scalaml.plots.Legend
    Try {
      (0.001 until 0.01 by 0.002).foreach(x => {
        val _alpha = if (alpha < 0.0) x else ALPHA
        val _eta = if (eta < 0.0) x else ETA
        val _etaStr = _eta.toString.substring(0, 5)
        val config = MLPConfig(_alpha, _eta, NUM_EPOCHS, EPS)

        val mlp = MLP[Double](config, SIZE_HIDDEN_LAYER, xv, expected)

        val confDesc = s"eta=${_etaStr}, alpha=${_alpha}"
        assert(mlp.model != None, s"$name run failed for $confDesc")

        mlp.display("err", Legend("MLP", s"Perceptron convergence for $confDesc", "Iterations", "Diff. error"))
        show(s"run for eta = ${_etaStr} and alpha = ${_alpha}\n${mlp.model.get.toString}")
      })
      1
    }
      .getOrElse(error("MLPConfigEval failed"))
  }
}

// ---------------------------------  EOF --------------------------------------------